Solution_contest14

[比赛链接](https://cn.vjudge.net/contest/168561)

# A

## Problem description

> 给出一串递增的数和c，只有当相邻两数相差<=c时才能维持前面的数，否则只留下这一个数。问最后还剩几个数。

## Solution

> 暴力从前往后扫，一旦相差超过c就把tot清为1，否则++tot。最终输出tot即可。

# B

## Problem description

> 给一段带有'A'\~'Z'以及'?'的字符串，问是否能改变'?'为'A'\~'Z'任意元素使其能够满足存在一个长度为26的连续的子串，包含了全部的'A'\~'Z'。

## Solution

> 维护一个长为26的单调队列，如果其内元素除了'?'以外没有重合，则只要把'?'改成所需元素就可以了。

# C

## Problem description

> 开始有一个数字2，然后有几个level，一开始在level 1；

>  假设我们在level k，我们有两个操作：

> 1_将数字加k;

> 2_将数字开方后跳到level(k+1)，但是有先决条件：首先这个数要能开方，其次这个数开方后要能被(k+1)整除

> 问题是，要跳到level(n+1)要怎么操作。

## Solution

> 假设当前level为k。设开方后的数为sqrt(x*k)。首先xk要能被(k+1)整除，其次它要是完全平方数。

> 所以最小的xk=(k+1)*(k+1)*k*k。

> 观察level k的起始的数————根据我们上述的最小假定————是(k-1)*k。

> 所以+的次数为(k+1)*(k+1)*k-(k-1)，只不过第一个数要特判。

# D

## Problem description

> 要修改一些能修改的边使得s-t的最短路长度为l。

## Solution

> 有两种方法，但首先都要判断是"Yes"还是"No"。

> 首先将可修改的边ban掉，如果最短路<l，"No"。

> 然后将可修改的边改成1，如果最短路>l，"No"。

> 剩余的都是"Yes"，为什么呢，可以这么想，我们首先能确定如果第一步的最短路>l，所以只要接下来最短路<l，那就一定有可修改边的参与。

> 然后我们随便抉择一个最短路路径上的可修改边，将其+1，最短路最多+1，要么不变。

> 重复进行如上述的操作以后，最短路一定会慢慢地变成l，所以"Yes"。

### Section 1

相当于是上述证明"Yes"的方法的过程的加速，就是说，我们每次不加1，设当前最短路为d，我们加(l-d)。

当然加一次肯定不够，加完后，我们跑一边最短路，继续加————知道最短路为l位置。

### Section 2

还有一种跑得飞快的方法。

首先从t跑一遍最短路，得知p[x]为从x-t的最短路径长度。

然后从s跑一遍最短路，当跑到可变边时，将其强行修改为l-d[x]-p[y]，x-y为这条边，d[x]为s-x的距离。

这为什么是对的呢，因为首先这保证了所有的路径>=l，并且总有一次修改是在p[y]没有被改变的时候，直接就修改成了l，所以这是对的。
