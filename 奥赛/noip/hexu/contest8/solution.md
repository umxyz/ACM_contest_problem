#A 题 
======================

大致题意：给你N支烟。很明显这N支烟吸过后会留下N个烟蒂，再给你一个K，表示每K个烟蒂可以换一支烟，问你最多可以吸几支烟？
  
  分析：我们可以设最终能抽x根烟，则x-n为额外抽的烟数，(x-1)/k为用烟蒂能换到的烟数（因为不允许借，否则是x/k），
       
       易知x-n<=(x-1)/k，化简后可得到x<=(kn-1)/(k-1)，则[(kn-1)/(k-1)]则为答案。
       
#B 题
======================

大致题意：给你N(2<=300)个空钱包，第I个钱包需要你往里面放A[I]（0<=A[I]<=300）块钱，现有一些规定：
        
        1.每单位时间你最多只能往你当前在的钱包里放1块钱。 
				
        2.你不能连续两个单位时间都是放钱。
				
        3.除了放钱，你也可以用1单位时间使你走到相邻的钱包前面，不过显然并没有第0个钱包和第N+1个钱包。
       
        4.你最多消耗的单位时间不能超过10,000；
   
   分析：因为最多有300个钱包，每个钱包里面最多有300块钱，那么放钱的操作最多只有90000次，因为不可以连续两次放钱，所以操作最多为3*90000=270000 次。
	      
        这点操作次数远远不会超过10,000这个数，所以就可以暴力乱搞了。
        
#C 题
======================

大致题意：给你N（3<=N<=3\*10^5）个数，你需要在一些数上加上一定的值，使得所有数字中不存在相同的数，并且使这N个数相加的值尽量地小。

分析：为了方便操作，我们先将这N个数进行一些排序，记录下每个数之前的位置方便输出答案，然后维护一个now值，now=max(now+1,a[i]); 没了。。。。
   
#D 题
======================

大致题意：给你4个数，k(3<=K<=50)，X(0<=X<=10^9), n,m(1<=N,M<=100). N表示字符串s1的长度，M表示字符串S2的长度。
        
        定义S(N)=S(N-2)+S(N-1). 现在定义一个字符组合"AC"的价值为1，显然S（N） 的价值与S(N-1) 和 s(N-2)的价值有关，
				
        现在要你求出一组合法的S1，S2，使得S(K)的价值等于X。可以任意输出一组。 
  
  分析：又题意可知，如果S1的价值为a1 ， S2 的价值为a2 ， 那么 s3的 价值为 a1+a2 ， 考虑到两个字符串相接时可能会生成新的一组"AC"，所以s3的价值在某些情况下可能等于s1+s2+1， 所以我们就发现了一些有趣的东西：
        
        1. 对于一个字符串，它的价值取决于它内部的AC组数，但是当这个字符串的首部的字符是C时，这个字符串就有机会和其他字符结合出一个新的“AC"，
        
           同样的，当这个字符串的尾部的字符是“A” 时，这个字符也会有机会和其他字符结合出新的“AC”。
        
        2. 假如我们用I,J分别来表示字符串s1内部的AC组数和字符串S2内部的AC组数，用 A,B,C,D（0<=A,B,C,D<=1) 来表示s1 和s2 的首部和尾部是否有
        
        字符”A“ 或 字符”C", 比如说a=1 表示s1的首部有一个空闲的C，b=1表示S1的尾部有一个空闲的A，c=1表示s2的首部有一个空闲的C，d=1表示s2的尾
        
        部有一个空闲的A。那么我们就很好的表示出了s1,s2的状态。
        
        3. 当我们知道了s1,s2 的状态时，我们就可以通过S(N)=S(N-2)+S(N-1) 这个公式 来计算S(K） 的价值了。
           
           假设 V[i] 表示 S（i ） 的价值，那么显然在不考虑字符串的组合会产生新的AC组合时，V[i]=v[i-1]+v[i-2]. v[1]= i; v[2] = j
           
           当我们考虑字符串的组合对V[I]的影响时，就可以很快发现从S(3)开始就会有一个有趣的规律，那就是S（奇数）是否形成新的AC组合与 b+c 是否
           
           等于2有关，S(偶数）是否形成新的AC组合与 d+c 是否等于2有关，那么我们就可以顺理成章的计算出S(K)的值了。
      
   经过这些有趣的分析，我们就可以暴力地枚举I,J,A,B,C,D的值，并且对于这些数的值来计算S(K)的值啦，其实我们只要找到一组I,J,A,B,C,D，使得S(K)=X，就可以直接输出答案啦。

#E 题 
======================

大致题意：给你一个N和一个K（1<=n,k<=300)，然后在接下来的N行，每行给出K+1个数，每个数代表一个坐标，第I个数就代表坐标（i-1, a[i]）， a[i]是这一行读进来的第I个数。 显然把同一行的k+1个坐标连起来可以形成一条折线，要你输出这条折线圈出的面积超出前面已经圈出的面积值，要求误差不能与标程的答案相差超过10^(-4) 。
   
   分析： 暂无。。。。。
   
#F 题
======================

大致题意：给你一棵树，这颗树有4个节点，编号分别为1 2 3 4 ，1 为2 3 4 的父亲节点，现在给你一个Q，紧接着是Q个正整数Xi(保证xi是这个树上的叶子节点),表示在xi 这个节点下面新建两个节点，这两个节点的编号为tot+1和tot+2 （tot 表示上次操作后树上的节点数） ， 并将这两个节点的父亲节点置为xi。
做完此次操作后输出当前树的直径。
   
        分析：由于添点操作只会在叶子节点上进行，所以这颗树的秩序有点特别之处，如果我们将根节点1的深度置为0。 将2,3,4的深度置为1， 新建的两个点的深度为
        
        它们父亲节点的深度+1，因为每次添加2个点，所以树的直径不一定通过根节点，有可能是其他的节点，所以我们就有必要写一个LCA了。
        
        那么设K1，K2表示上次操作后树的直径的两个端点的标号，ans为上次操作后的树的直径的长度，枚举新添加的节点分别于K1，K2进行组合，计算出分别组合
        
        的长度，与ans 进行比较就可以了。 那么怎么计算组合的值呢，我们设a,b为两个端点，c为a,b的LCA,那么路径的长度就会为dep[x]+dep[y]-2*dep[c];
        
        没了.
        
G 题
======================

大致题意：给你一颗仙人掌图，然后让你对这张图进行黑白染色，当然有些点也可以不染色，黑色点和白色点是不可以相邻的，现在问你当这张仙人掌图上分别染了0,1,2，......，n个黑色点的时候，白色点最多可以有几个。
   
   分析：暂无。。。。

