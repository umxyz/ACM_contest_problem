# Solution
```
/******************
  时间： 2017-06-20

    VJudge链接：  https://vjudge.net/contest/167793
******************/
```

***

## #A 
```
/******************
      主要算法：  KMP变形
******************/
```
### 题意
给你两个序列，求下面的序列在上面中"匹配"了几次,
对于一个匹配，模式串中相同的，匹配串也要相同，任意两个位置的相对大小关系在匹配串中也要满足
### 题解
KMP匹配的应用
如果A[0~k-1] B[0~k-1]匹配
那么A[k] B[k]延长匹配的前提是
前面的数中A[k]的前驱和后继的位置，在B中也是一样
出现A[k]的位置也应该出现B[k]
***
## #B 
```
/******************
      主要算法：  MST变形
******************/
```
### 题意
给一副图,10000个点 500000条边
100000个询问 每个询问给一个t，
求有多少点对之间的所有路径上的最大边权的最小值 >= t
### 题解
如果我们按照克鲁斯卡尔建最小生成树的方式建边
将边从小到大排序，我们会发现每次连接两个连通块的时候，这条边的边权
就是所有新构成点对之间所有路径上最大边权的最小值了，因为以后加的边都会更加大
将所有的点对数量保存一下，最后回答询问的时候二分一下即可

***
## #C 
```
/******************
      主要算法： 次小生成树
******************/
```
### 题意
求次小生成树 1000 个平面上的点
### 题解
删除最小生成树上的一条边，再给两个块连接一条边就可以得到一个新的生成树
朴素的做法就是枚举每一条树边去掉，然后枚举所有连接两个块的点对，找最小值连接起来
这样复杂度会比较大

观察到点数比较少，我们可以做一些预处理
以每个点为根dfs一遍求出：s[i][j]表示i到j子树所有点距离的最小值
然后利用s[i][j]可以求出opt[i][j]表示去掉i j这条树边后的重新连接的最小边权

***
## #D 
```
/******************
      主要算法：  可持久化字典树
******************/
```
### 题意
给你一个树，每个节点有一个值，给你若干个询问，x y z，求x 到 y路径上与z
xor值最大的 值
### 题解
解决这个题首先得能解决区间询问，区间跟树上其实是一样的。我们可以用可持久化字典树解决。
每个点都可以建立一颗到根的路径的字典树，然后对于一个询问x y z
假设lca为x y的最近公共祖先
那么x 到 y的字典树信息就是
字典树（x -> root） + 字典树 (y -> root) - 2*字典树(lca->root)
这样就可以提取出x 到 y路径上的字典树了.在字典树上从高位往低位走就可以求出答案
***
## #E 
```
/******************
      主要算法：  AC自动机
******************/
```
### 题意
从一个矩阵的左上角走到右下角，每次只能往右R 或者 往下D，
会形成一个RD构成的序列。现在给你两个串，表示路径中的一个子串，问你有多少种走法包含这些子串
### 题解
可以用KMP来dp，也可以用ac自动机，都是一样的,重点是记录当前构造的字符串匹配到了模式串的什么位置，
转移的时候可以利用kmp的nxt 或者 ac自动机的nxt来转移。
自动机的状态：dp[i][j][k][state]表示长度为i，共有j个R了，停留在k节点，状态是state的方案数

## 总结
各种算法的变形，需要对算法深入挖掘。
KMP变形，最小生成树变形。
