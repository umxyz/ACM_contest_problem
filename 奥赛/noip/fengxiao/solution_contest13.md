# Solution of contest 13
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/168406
CodeForces链接：  http://codeforces.com/contest/376

题目按CF顺序排序
******************/
```
# #A Lever
```
/******************
     主要算法：模拟
******************/
```
### 题意
给你个天平判断它的平衡情况
### 题解
右边维护一个力臂乘力，左边也一样。判断这两个值的关系得出答案

### 核心代码
```
/******************
这玩意还要核心代码？
******************/
```
***
# #B I.O.U.
```
/******************
    主要算法： 模拟
******************/
```
### 题意
给你一堆互相欠债的关系，让你将债务化简，比如a欠b 10元，b欠c 10元 那么就化简为a欠c十元
求出化到最简的债务值

### 题解
维护一个数组表示那个人将得到的钱的总数
### 核心代码
```
/******************
	for(i=1;i<=m;i++)
	{
		scanf("%d %d %d",&a,&b,&c);
		in[a]+=c; in[b]-=c;
	}
	for(i=1;i<=n;i++) ans+=abs(in[i]);
******************/
```
***
# #C Divisible by Seven
```
/******************
      主要算法：数论
******************/
```
### 题意
给你一个必定含1，6，8，9的数，改变其数位的排列顺序使其能被7整除，并输出那个数，如果不存在则输出0。~~不存在的~~
### 题解
纯粹的数学题，根据取模的性质：(a+b)%P=a%P+b%P,把那一坨数分成一组1689和别的东东，那么按自己喜欢的一个顺序排好除了那一组1689以外的数并求出其模数。  
记录一个数组表示由1，6，8，9组成的模7为i的数，然后两部分匹配使最终结果为0就可以了
### 核心代码
```
/******************
for(i=1;i<10;i++)
		while(cnt[i])
		{
			printf("%d",i);
			tmp=tmp*10+i; tmp=tmp%7;
			cnt[i]--;
		}
	cout<<b[tmp];
******************/
```

***
# #D Maximum Submatrix 2
```
/******************
      主要算法：前缀和 ~~DP~~
******************/
```
### 题意
给你一个01矩阵，可以互换行，求互换后的最大子矩阵
### 题解
第一眼看去一脸懵逼，脑中满是DP，然而并不是这么回事。  
用a[i][j] 表示第i行以第j个元素为结尾前面有多少个1（包括j）  
用b[j][i] 表示以每行第j个元素（第j列）为结尾的，前面有长度为i的1串的个数
那么很容易就可以算出答案了，**注意如果b[j][5]有5个的话那么b[j][4]也要在原有基础上加5**
### 核心代码
```
/******************
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			if(map[i][j]=='1')
			{
				a[i][j]=a[i][j-1]+1;
				b[j][a[i][j]]++;
			}
	for(j=1;j<=m;j++)
	{
		int c=0;
		for(i=m;i>=1;i--)
		{
			c+=b[j][i];
			ans=max(ans,c*i);
 		}
	}
******************/
```

# 赛后补题

***
# #E Circling Round Treasures	
```
/******************
      主要算法：BFS 数学 题意理解
******************/
```
### 题意
给你个map，其中包含#（障碍物） 数字（宝藏） B（炸弹） S（起点）  
要求从S开始走，如果路径包住了某个格子（穿过不算，同时宝藏和炸弹不可穿过） 那么这个格子就算属于路径中~~题目讲的那一坨根本不是人话~~  
要求路径不包括炸弹，**宝藏与炸弹之和小于等于8**
让你求出走完一个**封闭路径**后最大能获得的价值（宝藏价值-移动步数）
### 题解
先看到宝藏+炸弹<=8，想到用二进制储存，然后n，m只有20，想到暴力bfs，那么算法就出来了  
bfs整个map，当经过某个宝藏/炸弹下方时将其状态改变（取反），原因就是如果一个点在多边形内，那么它射出的仍以一条射线与多边形边有奇数个交点  
算法就这么完成了，然后需要注意经过这个点的路径的边界处理（刚好在这个点下面之类的）  
有一个很巧妙的方法就是对要去的点和现在在的点的x取个min
### 核心代码
```
/******************
for(int i=0;i<4;i++)
		{
			int step=p.step+1,v=p.v,x=p.x+dx[i],y=p.y+dy[i];
			if(i==2) v=v^sum[p.x][min(p.y,y)];
			if(i==3) v=v^sum[p.x][min(p.y,y)];
			if(!used[x][y][i^1][v] && ok(x,y) && p.from!=i)
			{
				
				used[x][y][i^1][v]=1;
				que.push((sta){x,y,i^1,v,step});
				if(!(v&P) && x==fx && y==fy)
				{
					//test(p.x,p.y,x,y,i^1,v,step);
					ans=max(ans,get_v(v)-step);
				}
			}
		}
******************/
```
***
***
# #F Tree and Queries
```
/******************
      主要算法：莫队
******************/
```
### 题意
给你一棵树，问你某棵子树中有多少种颜色的重复数大于等于k。
### 题解
先DFS将树拆成区间，  
然后运用莫队维护。
### 核心代码
```
/******************
void dfs(int u,int from)
{
	l[u]=++cnt;
	are[cnt]=c[u];
	for(int i=head[u]; i ;i=nxt[i]) if(to[i]!=from) dfs(to[i],u);
	r[u]=cnt;
}
void solve()
{
	int s=0,e=0;
	for(int i=1;i<=q;i++)
	{
		while(s<l[qu[i].x]) {_key[key[are[s]]]--; key[are[s]]--; s++;}
		while(s>l[qu[i].x]) {s--; key[are[s]]++; _key[key[are[s]]]++; }
		while(e<r[qu[i].x]) {e++; key[are[e]]++; _key[key[are[e]]]++; }
		while(e>r[qu[i].x]) { _key[key[are[e]]]--; key[are[e]]--; e--;}
		ans[qu[i].pos]=_key[qu[i].k];
	}
}
******************/
```
***

