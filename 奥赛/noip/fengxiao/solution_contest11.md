# Solution of contest 11
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/168242
CodeForces链接：  http://codeforces.com/contest/821

题目按CF顺序排序
******************/
```
# #A Okabe and Future Gadget Laboratory 
```
/******************
     主要算法：  模拟
******************/
```
### 题意
给你个矩阵，让你算是否每个元素（除1） 都可以由它所在行和列各挑出一个数相加得到  

### 题解
随便暴力一下呗  

### 核心代码
/******************
这还要核心代码？？  
******************/

***
# #B Okabe and Banana Trees
```
/******************
    主要算法： 模拟 数学
******************/
```
### 题意
这是一道恶心的题，给你一个函数，让你在这个函数的第一象限的部分选一点，与坐标轴形成矩形，求矩形上每个点的横纵坐标之和。

### 题解
直接做就可以了，大不了用数学方法让代码看起来短一点

### 核心代码
/******************
for(ll i=0;i<=b;i++)
	{
		ll j=(b-i)*m;
		ll sum=(i+1)*(j+1)*(i+j)/2;
		ans=max(ans,sum);
	}
******************/
***
# #C Okabe and Boxes
```
/******************
      主要算法：栈 模拟
******************/
```
### 题意
给你一个入栈以及出栈的顺序，如果发现没按1~n出栈，则可以将栈中元素reorder，求使其按1~n顺序弹栈所需的最少reorder数
### 题解
如果发现一定要reorder，那么栈之中的东西都可以“如意”地输出了，所以用个used标记一下是否可以直接输出，剩下的就是模拟了
### 核心代码
/******************
(若发现要reorder时的操作)
if(!sta.size()) { if(used[cnt]) cnt++; continue;}
if(sta.top()==cnt) {used[sta.top()]=1; sta.pop(); cnt++;}
else {ans++; while(!sta.empty()) {used[sta.top()]=1; sta.pop();} if(used[cnt]) cnt++;}
******************/

***
# #D Okabe and City
```
/******************
      主要算法： 最短路
******************/
```
### 题意
给你个map，里面有亮点和暗点。我们只能走在亮点上并且只能上下左右移动
同时当我们在原来就有的亮点上时可以花1coin点亮任意一行或一列的暂时亮点，当点亮另一行或列时原先的就会消失  
求从1,1到n，m的最少话费  
### 题解
~~很容易就想到要用最短路~~,先把目标点点亮（为了最短路），于是用方便的Dij，很容易知道如果两亮点相邻那么它们的代价为0  
空一行和不空行但不相邻的代价都是1(注意最后一个点要特判)，然后就可以愉快地最短路了，dis下标表示的是点。

### 核心代码
/******************
for(i=1;i<=k;i++)
	{
		minn=dis[0]; used[p]=1;
		for(j=1;j<=k;j++)
			if( (!used[j]) && (abs(a[p].F-a[j].F)<=2 || abs(a[p].S-a[j].S)<=2) )
			{
				if((abs(a[p].F-a[j].F)>=2 && abs(a[p].S-a[j].S)>=2) &&j==ans&& !flag) continue;
				if(j==ans&& !flag) {dis[j]=min(dis[j],dis[p]+1); continue;}
				for(int ii=1;ii<=4;ii++) if(a[p].F+dx[ii]==a[j].F && a[p].S+dy[ii]==a[j].S) {dis[j]=dis[p]; continue;}
				dis[j]=min(dis[j],dis[p]+1);
			}
		for(j=1;j<=k;j++) if(minn>dis[j] && !used[j]) {p=j; minn=dis[j];}
	}
******************/
***
# #E Okabe and El Psy Kongroo 
```
/******************
      主要算法：DP+矩阵快速幂优化
******************/
```
### 题意
给你一个坐标系，并给你一些x坐标连贯的线段，要求在线段与x轴之间走，每次能走向右上右下和正右  
问你让其达到K，0的方案数是多少。

### 题顺
瞬间就可以想到DP：f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1];
然而i的范围高达1e8，于是~~很快~~想到矩阵快速幂优化。  
构造矩阵递推式便可  


***
