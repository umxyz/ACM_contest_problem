A题题意：给出a根蜡烛，每b根燃烧完的蜡烛可换取1根蜡烛，问最多能燃烧多少根？
   思路：首先cnt=a，对于a根蜡烛，对b求整除值，则能换取新蜡烛，将其值加入cnt，并且将a对b取模，记录剩下的蜡烛，不断循环直至a为0，
        则cnt为燃烧蜡烛的最大值。
B题题意：给出一个整数n，再给出n个整数a[i]，起初在1位置，可投放一枚硬币，但不能连续在同一位置投放，可通过左右移动再回到该位置投放硬币，
        使得该位置的硬币数为a[i]后可离开，写出任意一种操作（操作数不超过10^6），使得每个位置i上都有a[i]个硬币。
        投放硬币用‘P’表示，向左移用'L'表示，向右移用‘R’表示。
   思路：根据题意暴力模拟，由于n<=300,a[i]<=300,则总操作数不大于3*300*300=270000次，不用担心超过步数限制。
C题题意：给出一个整数n，再给出n个整数a[i],要改变此序列，使得序列b[i]中没有重复元素，且对应i位置b[i]>=a[i]，并且使b[i]尽量小，
        给出任意一个可行的序列即可。
   思路：记录原序列数值num和位置id，按照num关键字排序。若a[i].num<>a[i-1].num则用一个变量j记录当前数a[i].num和j+1的最大值，赋给a[i].num，
        并将a[i].num的值返还给j，若a[i].num=a[i-1].num，则记录a[i-1].num和j+1的最大值，赋值给a[i].num，并同时将a[i].num的值返还给j，
        最后再将序列按id关键字重新排序回来即可。
D题题意：输入四个整数k，x，n，m，字符串s[1]的长度为n，字符串s[2]的长度为m，字符串s[n]=s[n-2]+s[n-1]，其中n>=3且n是整数，问使s[k]里含有x个
        字符子串AC的字符串s[1]和字符串s[2]分别是什么，给出任意一种方案即可，若无方案输出“Happy new year!”。
   思路：先不考虑字符串的头和尾，则新构造的字符串所含的AC个数为前两个字符串之和，构造斐波那契数列可以求得s[n]可能的AC个数，限制条件为s[1]最多
        可能含(n div 2)个字符串，s[2]中最多可能含(m div 2)个字符串，该构串枚举即可。再枚举头尾是A还是C，因为头尾是A是C可能影响构串时出现的
        AC个数，s[1]和s[2]枚举头尾的总次数为16。构完串时若长度有余，则全部填充B字符占位即可，若无方案，则在最后输出“Happy new year!”。
E题题意：给出整数n，k，再输入n行整数，每行有(k+1)个整数s[j]，分别表示第i个图形的坐标(j,s[j])，顺次将这些节点与(0,0)，(k,0)连接，得到图形i，
        编码越小的图形放置在坐标轴的越上方，计算每一个图形i未被遮盖的部分。
   思路：方法是计算几何，具体思路暂无。。。
F题题意：给出一棵原始树，树的根节点为1，树有三个子节点2,3,4。给定一个整数n，再给出n个整数x，在x下建立两个新的子节点，子节点的编号按照树里已有
        的最大编号依次递增，每次改建树后都要计算并输出树的直径，即该棵树中从一个节点到另一个节点的最长距离。
   思路：记录每个节点的深度，记录每个节点以上的父亲编号，寻找时跑一遍LCA，计算树的直径两端点的公共祖先，并相应改变树的直径两个端点的位置，直至
        找到树的直径。
G题题意：暂无。
   思路：暂无。
