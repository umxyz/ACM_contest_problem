A题题意：给出整数n，m，N，表示每n个人里有m个人说方言，问N个人里最多有多少人会讲方言。
   方法：按题意模拟。
   思路：计算M=(N+1)*m/n，若M>N则M=N，输出M的值即可。
B题题意：第一行输入整数n，m，表示有n个人要围在圆桌前吃饭，接下来m行每行各有一个整数a[i]，表示第i个人想要和a[i]坐在一起，问有几种排座位的方式。
   方法：并查集。
   思路：记录数组s[i]表示对于i有多少子节点（包含i），d[i]表示想要与i加上i想要与他人坐一起的人的总数。刚开始将n个人视为n棵分散的子树，sum记录树的
        个数，初值为n。对于m行读入的数，如果两人之间还未建边，则vis[x][i]=vis[i][x]=true，d[x]+1，d[i]+1。接下来如果find(x)!=find(i)，则
        s[find(i)]+=s[find(x)]，fa[find(x)]=fa[find(i)]，sum-1；如果find(x)==find(i)，则说明含x和含i的树变成环，标记flag=1,。处理完数
        据后，如果n=2，则特判输出1，否则枚举d[i]的值，若d[i]>2，则肯定不存在可行的排列方式，输出0，如果子树的数量大于1，且有环，则肯定也找不出可
        行的方式，输出0。在接下来，计算方案数ans=(sum-1)!，然后枚举每个节点，如果fa[i]=i且s[i]>1，则说明树的摆放情况不唯一，ans*=2。中间计算
        时，不要忘记对1000000007取模。最后输出ans即可。
C题题意：输入一个四边形的四个顶点，求该四边形的对称轴个数并乘以2。
   方法：几何法求解。
   思路：由于对称轴最多的四边形正方形也只有四条对称轴，所以我们只要寻找特殊的四边形判断即可。首先我们判断是否有两组邻边分别相等，如果存在，则含有1条
        对称轴，在此基础上判断四边形是否四条边都相等，若相等则为菱形，含有2条对称轴，在此基础上判断四边形是否有一个直角，若有则为正方形，含有4条对
        称轴。如果两组对边分别相等且有一个角是直角，则为矩形，有两条对称轴。如果有一组对边相等且不平行，另一组对边平行，则为等腰梯形，有1条对称轴。
        记向量a(x1,y1)，b(x2,y2)，判断a垂直于b：x1x2+y1y2=0，a平行于b：x1y2-x2y1=0。接下来模拟即可求解。
D题题意：第一行给出整数n，m，第二行给出m个整数a[i]。数据含义为：有n个人，有m种语言，第i种语言有a[i]个人会，计算至少有几个人m种语言全会。
   方法：按题意模拟。
   思路：记变量t=n，枚举每一个a[i]，使t=t+a[i]-n，执行过程中若t<=0，则直接输出0并退出程序。否则到最后枚举完成输出t即可。
E题题意：第一行输入整数n，第二行给出n个整数a[i]，保证每个a[i]，互不相等且在[1,n]的范围内。问是否能在原序列中拆出两个增数串或两个减数串或一个增数串
        加上一个减数串。若能，先在第一行输出两个串的长度，接下来两行输出两个串分别是什么，每个数之间用空格隔开，输出任意一种可行的方案即可。否则输
        出“Fail”。
   方法：动态规划。
   思路：用dir[0]，dir[1]（两者值域为[0,1]），记录第一列可能拆出的数列和第二列可能拆出的数列的增减情况。再去寻找满足情况的序列，寻找完后打印即可。
F题题意：第一行输入两个整数n，m，接下来n行每行两个整数x，y，是n个点的坐标，再接下来m行每行两个整数x，y，表示将第x个点与第y个点连接起来。如果所连接
        的m条线段中有相交的，则两条相交线段上的任意两点之间也记为相通。问给出的线段是否能将所有点互相连通。
   方法：并查集，几何法求解。
   思路：将输入数据中两个已经相连的点并查集记录相连，然后遍历每个点，看看是否有其他点已经在连好的线段上，若有，并查集记录相连，否则枚举两两线段之间
        是否相交，若相交则用并查集记录相连这2条线段的4个端点。最后遍历每个点i的fa[i]，若fa[i]全部等于fa[0]，则输出“YES”，否则输出"NO"。
G题题意：原本有一个10*10的图片，现在将其拆成9块4*4的图片，图片的横纵坐标分别属于原来图片的[1,4]，[4,7]，[7,10]的范围内，每张4*4的图片随机给出且
        有可能被打乱过。打印一种原来10*10的图片的可能情况。
   方法：按题意模拟，DFS。
   思路：可将题意看作原10*10图片分成9块，每块有一条重合的边，因此我们拼图时，先判断该块拼图所属的位置，在DFS中记录，再判断该块拼图的重边位置上的数
        是否与其相邻的拼图块重边位置上的数相同。若相同则可行，vis[i]记录第i块拼图已用过，否则旋转该拼图，若旋转四次该拼图仍不可行，就换一块拼图，
        直到9块拼图全部归位为止。
