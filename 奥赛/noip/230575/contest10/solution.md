A题题意：给出整数n，再给出长度为n的只含字符0和1的字符串，相邻的0和1可以删除，问最后剩下字符串的最小长度是多少？
   思路：统计字符串中0的数量，由于0和1在不断删除的过程中必定会相邻，所以只需统计0的个数x，再计算abs(x*2-n)的值即可。
B题题意：给出整数n，再给出n个整数a[i]，我们可以执行操作，使所有奇数位置上的数加1，若该数值大于等于n，则减去n，同时使所有偶数位置上的数减1，若该数值
        小于等于0，则加上n，问是否能在若干次操作后使n个整数a[i]都满足a[i]=i-1。若能输出“Yes”，否则输出“No”。
   思路：我们分析可以得出操作n次后，序列一定会变为原序列，进而重复循环，我们只需在n步内得出要求的序列就输出“Yes”，否则输出“No”，思维难度较低，按照
        题意暴力模拟即可。
C题题意：第一行给出整数n，k，接下来k行，每行第一个整数为m，此处保证k个m之和为n，该行再给出m个整数a[i]，表示a[i]在a[i+1]内部，我们的目的是使1在2
        内，2在3内，...，n-1在n内。我们可进行一边操作，每遍操作可以使数字小的套在数字大的内部，或将数字小的数字从数字大的内部拿出，问至少几次操作
        后可达到目标状态。
   思路：找到含有1的初始数列，计算1之后是否已经有连续递增的数列，因为这些已经排好的数列无需拆开重组，其他的所有数字需先从大的数中拿出来再重新组合。
        于是我们记录1后连续递增的数的个数num，sum=n-k-num+1，最后sum=sum+n-num，输出sum的值即可。
D题题意：第一行给出整数n，m，接下来n行给出两个数l，r，表示岛屿i的覆盖范围为[l，r]，这里保证l[i]<=r[i]<l[i+1]<=r[i+1]，再接下来1行输入m个数，表
        示m座桥的长度，一座桥若其长度在闭区间[l[i+1]-r[i],r[i+1]-l[i]]内，则桥可搭建在岛屿i和i+1之间，一座桥只能用一次，问是否能在所有岛屿之间
        搭建上桥，若不能输出“No”，若能输出“Yes”，并按顺序输出n-1个数，即i和i+1之间用的是哪座桥。
   思路：定义数组a可包含三个元素left，right，id，a[i].left记录l[i+1]-r[i]的值，a[i].right记录r[i+1]-l[i]的值，a[i].id记录i与i+1之间的空隙
        编号i。定义数组b可包含两个元素num，id，b[i].num记录桥i的长度，b[i].id记录桥i的编号i。将a按主关键字left，次关键字right排序，将b按关键字
        num排序，两者的排序都是从小到大。倒序寻找对于排好序的岛屿i与i+1需要哪座桥，寻找桥的标号用倍增法以提高搜索效率，若此座桥之前已用过，则指向
        前面还未用过的长度最大的桥，数组c[a[i].id]=b[i].id，记录未排序前i与i+1需要的桥的编号，若桥i-1也已用过，则并查集记录前面最长未用过的桥的
        编号，fa[get(x)]=get(x-1)，同理，fa[get(x+1)]=get(x),由此可推断出所有岛屿之间需要哪座桥。若寻找过程中有两个岛之间找不到满足条件的桥，
        则直接输出“No”，并直接退出程序。
E题题意：第一行给出整数n，m，即同时给出一个n*n的巧克力矩阵，将从左下角到右上角的n块巧克力作为对角线，设矩阵对角线右下方的部分不存在。接下来m行输入
        两个整数x[i]，y[i]，和一个字符c，数据保证x[i]+y[i]=n+1，即坐标保证i初始位置处于对角线，c保证是“U”或“L”，“U”为点i可向上移动吃巧克力，一
        直遇到不能再吃巧克力为止，“L”为点i可向左移动吃巧克力，一直遇到不能再吃巧克力为止，必须按照给出的运动顺序吃巧克力，即i吃完巧克力，i之后的点
        才可行动。问对于每个点i可吃到多少巧克力。
   思路：将所有点的横坐标a[i]从小到大排序，同时点的出发顺序b[i]也要跟随点的横坐标相应参与排序，x[b[i]]表示未排序前标号为i的点的横坐标是第k小的。之
        后将a[i]去重，用于记录互不相同的横坐标，统计出互不相同的元素个数为k，并使a[0]=0，a[k+1]=n+1，构造线段树维护，用pos[i]记录第i个数在线段
        树上的位置，即其在线段树相应位置的树的节点编号。vis[x[i]]表示i操作时，该点是否被使用过，若使用过，即为true时，则该点已不存在，直接输出0。
        若该点还存在，则若该点是向上走的，找出其能走到的最上方处，并改变其横坐标右边的点向左走能到达的最远的地方，同理，若该点是向左走的，找出其能走
        到的最左处，并改变其纵坐标下方的点向上走能到达的最远的地方，不停地在线段树上操作并改变即可求解。
