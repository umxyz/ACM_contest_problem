A题题意：给出一根杠杆，用字符串表示，字符“^”表示杠杆的支点，字符“=”表示杠杆未挂勾码的地方，数字i（保证是在[1,9]范围内的整数）表示在该位置挂了一个
        质量为i的勾码。判断该杠杆是否平衡，若平衡输出“balance”，若左边重输出“left”，若右边重输出“right”。
   方法：按题意模拟。
   思路：先找整个字符串，标记支点的位置mid，然后查找整个字符串，若位置i<mid，则属于左边，left+=(s[i]-'0')*(mid-i)，若位置i>mid，则属于右边，
        right+=(s[i]-'0')*(i-mid)，当然要注意判断s[i]是数字时，才能做此操作。最后判断left和right的大小即可。
B题题意：第一行输入整数n，m，接下来m行每行三个整数a，b，c，表示第a个人欠第b个人c元。假设存在A欠B共20元，B欠C共20元，则可以看作A欠C共20元，B谁也
        不欠。则根据该分析，算出欠钱最少的总和。
   方法：按题意模拟。
   思路：用数组f记录一个人欠钱情况，对于输入的a，b，c，f[a]+=c，f[b]-=c，最后搜索n个人的f数组上的值，若大于0则ans+=f[i]，最后输出ans即可。
C题题意：输入一个数n，n里保证1,6,8,9四个数字至少出现一次，别的数字也会存在，问怎样组合排列这些数字，是它被7整除。
   方法：数学法模拟。
   思路：将0出现的个数统计下来，便于最后直接加在后面。分别保留一个1,6,8,9，其他的数字直接输出并计算它们组合出来的数的余数num=(num*10+a[i])%7,
        由于10003,20006,30002,40005,50001,60004被7整除，1869,6198,1896,1689,1986,1968,1698除以7分别余3,6,2,5,1,4，所以根据再相应输出
        这6个数中的一个，把所有的零在末尾补上即可。
D题题意：给出n，m，再给出n*m的01矩阵，矩阵的横行可以互换，计算只含1的子矩阵的最大面积。
   方法：动态规划。
   思路：先记录每一行的相应位置上连续出现的1的个数h[i][j]，再将每一行出现的个数从大到小sort一遍，原因是越大的连续1越难以与较小的连续的1组成子矩阵，
        因此最后对于每一行ans=max(ans,h[i][j])即可算出答案。
E题题意：给出两个整数n，m，再给出一个n*m的图，数字表示宝藏，B表示炸弹，S表示起点，“.”表示道路，“#”表示墙。每个宝藏都有一定的价值且可能为负。我们从
        S出发，回到S，中途可走路围成一个多边形，将宝藏包围起来，但不能包围炸弹，每走一个格子将减少价值1，问能得到的最大价值为多少。
   方法：宽搜，多边形包围点的判断。
   思路：一个多边形若包围着一些点，则往这个点一侧作一条无限远的直线，必然交于多边形的次数为单数。所以我们用一个二进制表来判断是否能包围点。二进制数
        的相应位置若为1表示包围了该点，否则不包围该点，该操作结合在宽搜中进行。
F题题意：第一行给出整数n，m，第二行n个数，表示每个节点的颜色。接下来n行给出(n-1)条边，使得n个点构成一棵树。再接下来m个询问，询问以n[i]为根节点的整
        棵子树中同种颜色的节点个数大于等于k[i]个的颜色数有几种。
   方法：启发式合并，分块。
   思路：记录遍历该数的dfs序，每个节点都有第一次进入该节点的序数l[i]和离开该节点再不进入的序数r[i]，我们先将序列按l[i]排序从小到大，再按r[i]排序，
        然后分块分成sqrt(n)块进行操作。模拟两个端点left，right，left初值为1，right初值为0。若left>l[i]，则++c[++s[v[--left]]，意为将left
        左移后v[left]的颜色多了一个，所以颜色总数为s[v[left]]的可能也多了一个。最后ans[i]=c[k[i]]即可。
G题题意：第一行给出整数n，k，表示树有n个节点。第二行n个整数a[i]，保证a[i]在[0,1]范围内。0表示节点为红色，1表示节点为黑色。问至少交换几次红黑节点，
        使得每个红节点到最近位置的黑节点的距离均不大于k。若无可行方案，输出-1，否则输出交换的最小次数。
   方法：暂无。
   思路：暂无。
