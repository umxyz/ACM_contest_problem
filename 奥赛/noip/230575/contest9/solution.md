A题题意：第一行输入n，m，k，第二行输入n个数a[i]，接下来m行每行三个整数l，r，d，记为操作b[i]，即a[l]到a[r]都加上d，再接下来k行每行2个整数x，y，
        即做操作b[x]到b[y]，最后输出改变后的序列。
   思路：维护两个树状数组。一个维护序列，一个维护操作，然后再区间修改，单点询问即可。
B题题意：输入整数n，再输入n*n的矩阵，保证a[i][j]都小于等于10^5且大于等于1，且a[i][i]=0，a[i][j]表示i到j单向边的路径长，再给出n个整数，表示依次
        删除节点b[i]以及所有与b[i]相连的边，再计算所有还存在的两两节点之间的最短路之和。
   思路：倒着来做，用ans[k]表示节点b[k]删除之前的最短路之和，求最短路时跑一遍弗洛伊德即可求解。
C题题意：第一行给出整数n，k，第二行给出n个整数a[i]，表示n个人的重量，a[i]只可能为50或100，k表示一艘船最大载重，刚开始所有人都在河岸的一边，求出最
        小的步数，使所有人都到河对岸，并求出所有可行方案数之和 mod 10^9+7的值。若无任何方案则第一行输出-1，第二行输出0。
   思路：先求出对于i个相同体重的人中取j个人过河可组合出的不同方案数，用c[i][j]表示，递推公式为c[i][j]=c[i-1][j-1]+c[i-1][j]，边界条件为c[i][0]
        =1,再用数组f[t][i][j]表示船在一岸时，河的(t mod 2)岸有i个体重为50的人和j个体重为100的人，t mod 2=0时表示船在最初河岸，t mod 2=1时表示
        船已抵达对岸，初始条件f[0][a][b]=1，其中a为体重为50的总人数，b为体重为100的总人数，f数组记录的是总方案数，若存在f[t(t mod 2=1)][a][b]
        <>0，则有可行的方案，输出t和f[t][a][b],否则若载人步数超过n*4，则接下来肯定无可行方案，输出-1和0。
D题题意：你有一个n*m的棋盘，n行，m列，棋盘每个格子的颜色可以是黑色也可以是白色。当满足全部下述条件，则认为出现了一个Cave。
        1.若存在一个线段[l,r]，(1<=l<=r<=n)，使得l，l+1，l+2，...，r这些行都有且仅有两个黑色棋子，其他行不存在黑色格子。
        2.存在一个行号t（l<=t<=r），使得：对于任意存在黑色格子的行a，把这行的黑色格子对应的列号和黑色格子之间的列号加入一个集合，称之为S(a)。
                                       任取t及t之上的两个有黑色格子的行，令上方的行为u，下方的行为d，则S(u)是S(d)的子集。
                                       任取t及t之下的两个有黑色格子的行，令上方的行为u，下方的行为d，则S(d)是S(u)的子集。
        你要输出有多少染色的方案，使得棋盘出现一个Cave，答案模1000000007(10^9+7)。
   思路：DP。具体暂无。
E题题意：第一行一个整数n，第二行n个整数a[i]，表示在数轴上有n个点，坐标分别为a[i]，第三行一个整数m，接下来m行，每行三个整数p，x，y，若p=1，则
        给a[x]加上整数y，若p=2，则输出数轴上闭区间[x,y]之间所有点之间的距离之和。
   思路：线段树维护。具体暂无。
