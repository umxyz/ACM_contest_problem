A：好像可以用线段树做。。然而打标记就可以线性解决了。。
B：正难则反。。删点难做就反过来加点嘛。。
   对于一个已经求完两两最短路的图G，加上点x，先求x到u（u属于G）的距离（我使用spfa的），再求u（u属于G）到x的距离，最后把x当中间点跑弗洛伊德。。
C：dp啊。。自行yy就好。。此题只不过代码容易写wei而已。。
D：题意是这样的：
  0000000    001000100
  0001100    000110000
  0010010
  0010100    11
  0000000    11
    以上形状均可称为一个洞。。（很生动是不是？。。）
  问：n*m的矩阵可能有多少个不同的洞？（位置不同也算不同）
  dp啊。。f[i][j]表示第i行中"100...001"（也可能没有0）的长度为j的种数。。
         g[i][j]表示第i行中"100...001"（也可能没有0）的长度为j且上一层长度不为j的种数。。（然而g[i][j]=f[i][j]-f[i-1][j]）
  则答案就是。。Σf[i][j]*g[n-i+1][j]*(m-j+1) (1<=i<=n,2<=j<=m)
E:离散化+线段树。。
  最妙的地方是最初离散化是对所有可能出现的值离散的。。
  线段树的节点记录三个值：siz，sum，ans（字面意思）。。
    合并注意一下：	t3.siz=t1.siz+t2.siz;
	                t3.sum=t1.sum+t2.sum;
	                t3.ans=t1.ans+t2.ans+t1.siz*t2.sum-t2.siz*t1.sum;（自行yy就好了。。）
  然后就是简单的（我心虚了。。）二分、单点修改、区间查询。。而已。。
