A：略。。
B：略。。
C：我的做法比较原始，先模拟拆成连续的几段，在模拟合并。。（题意要理解清楚）。。
D：这题题意可以转换为给n-1个区间[li,ri](1<=i<n)(1<=li<=ri<=m)。。在每个区间内各取取一个值ansi。。使ansi各不相同。。
  比赛时没想到正确的贪心。。只想到O(m2)的做法。。在第12个点TLE了。。
  后来在大佬们的指教下发现可以按l sort过后贪心。。对于每一个t(1<=t<=m)找所有l<=t的区间(当然，还没有确定这个区间的ans)中r最小的区间。。
  这个区间的ans赋为t。。
E：方法一————离散化+前缀和+线段树：略。。
   方法二————平衡树：对于每一个查询。。我们可以用之前坐标最靠近的（'U'向右找，'L'向左找）一次咬。。可以推哦！。。
                   以'U'为例：
                   111111
                   11111
                   1111<——这是往右最近的一次咬。。
                   111
                   11<——假设现在从这里往上咬。。
                   1
                   
                   case 1：
                   111111
                   11111
                   0000<——向上到此为止。。
                   111
                   11<——
                   1
                   
                   case 2：
                   111011
                   11101
                   1110<——TA能到哪里。。就能到哪里。。
                   111
                   11<——
                   1
