# The Solution


## #A -Greg and Array

> 时间限制：  1.5s
>
> 空间限制：  256MB
>
> 主要算法：  拆分前缀和

### 题意 给定你一个串，以及m个操作，然后输入k，表示将l~r一段范围的操作进行累加，然后输出操作完的结果
### 题解 运用两遍拆分首先将累加的k进行拆分，然后m个操作乘上对应的次数，然后再进行一次，原数组加上对应的次数。


## #B Greg and Graph

> 时间限制：  3s
>
> 空间限制：  256MB
>
> 主要算法：  FLoyd

### 题意 给定一个邻接矩阵，求去掉一个点后其他各点对的距离之和
### 题解 我们可以考虑离线的做法，首先将删掉的点保存下来，然后从后往前，把点一次加上去。其实就是FLoyd只不过加上一个点之后，对所有节点进行松弛（注意是所有节点，这样后面的节点就不用再进行松弛了），我们输出由于不输出没有加入的点，所以没有后效性。时间复杂度o(n^3)
### 我的错误做法：每一次加入的点的松弛操作不一样。假设加入到n，我的松弛顺序为1\~n-1->1\~n-1通过n,1\~n-1->n通过1\~n-1,n->1\~n-1通过1\~n-1，这样计算的话后面的节点没有考虑，然后就有bug。


## #C Greg and Friends

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  dp or 记忆化搜索

### 题意：给定你一条船的载重以及若干个人的重量（50或100），求到沿岸的最小的步数和达到最小的步数的方案数
### 题解首先化简题目，将50100映射成12然后我们设f[0/1][i][j]s[0/1][i][j]分别表示方案数和步数，可以列出dp方程
> f[1][i-u][j-v]=f[0][i][j]*c[i][u]*c[j][v];    
> s[1][i-u][j-v]=s[0][i][j]+1;    
> f[0][u][v]=f[1][i][j]*c[cnt[1]-i][u-i]*c[cnt[2]-j][v-j]   
> s[0][u][v]=s[1][i][j]+1;
### 然后枚举所有的i,j,u,v就可以了。注意判断边界。


## #D Greg and Caves

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  字符串匹配（KMP）

### 题意
### 题解


## #E Yaroslav and Points

> 时间限制：  5s
>
> 空间限制：  256MB
>
> 主要算法：  计算几何 凸包

### 题意
### 题解
