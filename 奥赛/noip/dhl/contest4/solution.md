# The Solution


## #A -Twins

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  贪心 

### 题意 无
### 题解 无


## #B Unlucky Ticket

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  模拟

### 题意 无
### 题解 无

## #C Find Pair

> 时间限制：  1s
>
> 空间限制：  256MB
>
> 主要算法：  模拟

### 题意：给定你若干个数字，按照Pair的排序标准，求出组合之后第i位的组合
### 题解：模拟，建议先写一份暴力，然后对题目有理解之后再写正解


## #D Edges in MST

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  桥，最小生成树，并查集

### 题意：求若干条边在不一定唯一的最小生成树的使用情况，唯一，还是不唯一，或者不用。
### 题解：首先可以明确，唯一的边就是桥，因为他是连接两个联通快的。然后我们对边的长度进行分层，跑一次克鲁斯卡尔算法，当且仅当一层的边满足桥的关系输出"any“否则输出"at least one"细节也是要注意的，注意还要加读入优化，不然会T掉


## #E Buses and People

> 时间限制：  1s
>
> 空间限制：  256MB
>
> 主要算法：  线段树，离散化

### 题意：给定人和车子的起始和末尾，以及时间，满足人的区间在车子区间之内，并且人的时间戳要小于等于车子的时间戳
### 题解：看数据范围，要用nlogn的算法。我们按照起始的时间进行排序，并且让车子的时间在人的时间的前面，因为这样更新完才会求人，然后建立一个线段树，每一个节点，维护id和右区间，当加入车子的时候，我们更新右区间，查询根据区间进行。我们维护时间的时候要用二分查找，在离散化后的时间里面收到节点，进行查询就可以了
>首先很容易想到排序，把汽车和乘客的信息放在一起排
第一关键字 出发的站点 
第二关键字 id（乘客的id排在汽车后面）
这样的话如果汽车和乘客的出发站点是一样的，汽车会派到前面
这样一排之后，有一个好处是排在乘客后面的汽车肯定是出发站点比乘客大的 即s>start，所以乘客不会坐上后面的车走
>然后离散化，对时间建树，每个节点保存区间内最右的车站。单点更新即可。
